#![cfg(feature = "vectors")]
//! H3 HELLO-open and envelope-open golden vector tests.
//!
//! Loads web-hello-open.vectors.json and envelope-open.vectors.json
//! (generated by TS SDK) and verifies that the Rust `open_box_payload`
//! produces identical decrypted inner JSON for each test case.
//!
//! Also includes seal-then-open round-trip tests (non-golden).

#![allow(non_snake_case)]

use serde::Deserialize;
use std::path::PathBuf;

// ── HELLO vector schema ──────────────────────────────────

#[derive(Deserialize)]
struct HelloVectors {
    version: u32,
    cases: Vec<HelloCase>,
}

#[derive(Deserialize)]
struct HelloCase {
    name: String,
    sender_public_hex: String,
    receiver_secret_hex: String,
    sealed_payload_base64: String,
    expected_inner: serde_json::Value,
}

// ── Envelope vector schema ───────────────────────────────

#[derive(Deserialize)]
struct EnvelopeVectors {
    version: u32,
    cases: Vec<EnvelopeCase>,
}

#[derive(Deserialize)]
struct EnvelopeCase {
    name: String,
    sender_public_hex: String,
    receiver_secret_hex: String,
    envelope_json: EnvelopeFrame,
    expected_inner: serde_json::Value,
}

#[derive(Deserialize)]
struct EnvelopeFrame {
    #[serde(rename = "type")]
    msg_type: String,
    version: u32,
    encoding: String,
    payload: String,
}

// ── Helpers ──────────────────────────────────────────────

fn vectors_dir() -> PathBuf {
    let manifest = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    manifest
        .join("..")
        .join("..")
        .join("ts")
        .join("bolt-core")
        .join("__tests__")
        .join("vectors")
}

fn hex_to_32(hex: &str) -> [u8; 32] {
    let bytes = bolt_core::encoding::from_hex(hex).expect("invalid hex");
    bytes.try_into().expect("expected 32 bytes")
}

// ── HELLO open tests ─────────────────────────────────────

#[test]
fn hello_open_golden_vectors() {
    let path = vectors_dir().join("web-hello-open.vectors.json");
    let data = std::fs::read_to_string(&path)
        .unwrap_or_else(|e| panic!("failed to read {}: {}", path.display(), e));
    let vecs: HelloVectors =
        serde_json::from_str(&data).expect("hello open vectors failed to parse");

    assert_eq!(vecs.version, 1);
    assert!(
        vecs.cases.len() >= 3,
        "expected at least 3 HELLO open cases, got {}",
        vecs.cases.len()
    );

    for case in &vecs.cases {
        let sender_pk = hex_to_32(&case.sender_public_hex);
        let receiver_sk = hex_to_32(&case.receiver_secret_hex);

        let decrypted = bolt_core::crypto::open_box_payload(
            &case.sealed_payload_base64,
            &sender_pk,
            &receiver_sk,
        )
        .unwrap_or_else(|e| panic!("HELLO open failed for case '{}': {}", case.name, e));

        let inner: serde_json::Value = serde_json::from_slice(&decrypted).unwrap_or_else(|e| {
            panic!(
                "HELLO inner JSON parse failed for case '{}': {}",
                case.name, e
            )
        });

        assert_eq!(
            inner, case.expected_inner,
            "HELLO inner mismatch for case '{}'",
            case.name
        );
    }
}

#[test]
fn hello_open_wrong_key_rejects() {
    let path = vectors_dir().join("web-hello-open.vectors.json");
    let data = std::fs::read_to_string(&path)
        .unwrap_or_else(|e| panic!("failed to read {}: {}", path.display(), e));
    let vecs: HelloVectors =
        serde_json::from_str(&data).expect("hello open vectors failed to parse");

    let wrong_key = [0xFFu8; 32];

    for case in &vecs.cases {
        let receiver_sk = hex_to_32(&case.receiver_secret_hex);
        let result = bolt_core::crypto::open_box_payload(
            &case.sealed_payload_base64,
            &wrong_key,
            &receiver_sk,
        );
        assert!(
            result.is_err(),
            "HELLO open should fail with wrong key for case '{}'",
            case.name
        );
    }
}

#[test]
fn hello_seal_then_open_roundtrip() {
    let kp_a = bolt_core::crypto::generate_ephemeral_keypair();
    let kp_b = bolt_core::crypto::generate_ephemeral_keypair();

    let inner = r#"{"type":"hello","version":1,"identityPublicKey":"dGVzdA==","capabilities":["bolt.file-hash"]}"#;
    let plaintext = inner.as_bytes();

    let sealed = bolt_core::crypto::seal_box_payload(plaintext, &kp_b.public_key, &kp_a.secret_key)
        .expect("seal failed");

    let decrypted =
        bolt_core::crypto::open_box_payload(&sealed, &kp_a.public_key, &kp_b.secret_key)
            .expect("open failed");

    assert_eq!(decrypted, plaintext);
}

// ── Envelope open tests ──────────────────────────────────

#[test]
fn envelope_open_golden_vectors() {
    let path = vectors_dir().join("envelope-open.vectors.json");
    let data = std::fs::read_to_string(&path)
        .unwrap_or_else(|e| panic!("failed to read {}: {}", path.display(), e));
    let vecs: EnvelopeVectors =
        serde_json::from_str(&data).expect("envelope open vectors failed to parse");

    assert_eq!(vecs.version, 1);
    assert!(
        vecs.cases.len() >= 3,
        "expected at least 3 envelope open cases, got {}",
        vecs.cases.len()
    );

    for case in &vecs.cases {
        // Validate envelope frame structure
        assert_eq!(
            case.envelope_json.msg_type, "profile-envelope",
            "envelope type mismatch for case '{}'",
            case.name
        );
        assert_eq!(
            case.envelope_json.version, 1,
            "envelope version mismatch for case '{}'",
            case.name
        );
        assert_eq!(
            case.envelope_json.encoding, "base64",
            "envelope encoding mismatch for case '{}'",
            case.name
        );

        let sender_pk = hex_to_32(&case.sender_public_hex);
        let receiver_sk = hex_to_32(&case.receiver_secret_hex);

        let decrypted = bolt_core::crypto::open_box_payload(
            &case.envelope_json.payload,
            &sender_pk,
            &receiver_sk,
        )
        .unwrap_or_else(|e| panic!("envelope open failed for case '{}': {}", case.name, e));

        let inner: serde_json::Value = serde_json::from_slice(&decrypted).unwrap_or_else(|e| {
            panic!(
                "envelope inner JSON parse failed for case '{}': {}",
                case.name, e
            )
        });

        assert_eq!(
            inner, case.expected_inner,
            "envelope inner mismatch for case '{}'",
            case.name
        );
    }
}

#[test]
fn envelope_open_wrong_key_rejects() {
    let path = vectors_dir().join("envelope-open.vectors.json");
    let data = std::fs::read_to_string(&path)
        .unwrap_or_else(|e| panic!("failed to read {}: {}", path.display(), e));
    let vecs: EnvelopeVectors =
        serde_json::from_str(&data).expect("envelope open vectors failed to parse");

    let wrong_key = [0xFFu8; 32];

    for case in &vecs.cases {
        let receiver_sk = hex_to_32(&case.receiver_secret_hex);
        let result = bolt_core::crypto::open_box_payload(
            &case.envelope_json.payload,
            &wrong_key,
            &receiver_sk,
        );
        assert!(
            result.is_err(),
            "envelope open should fail with wrong key for case '{}'",
            case.name
        );
    }
}

#[test]
fn envelope_seal_then_open_roundtrip() {
    let kp_a = bolt_core::crypto::generate_ephemeral_keypair();
    let kp_b = bolt_core::crypto::generate_ephemeral_keypair();

    let messages = [
        r#"{"type":"ping","ts_ms":12345}"#,
        r#"{"type":"pong","ts_ms":12346,"reply_to_ms":12345}"#,
        r#"{"type":"app_message","text":"round trip test"}"#,
    ];

    for msg in &messages {
        let sealed =
            bolt_core::crypto::seal_box_payload(msg.as_bytes(), &kp_b.public_key, &kp_a.secret_key)
                .expect("seal failed");

        let decrypted =
            bolt_core::crypto::open_box_payload(&sealed, &kp_a.public_key, &kp_b.secret_key)
                .expect("open failed");

        assert_eq!(decrypted, msg.as_bytes());
    }
}

// ── Vector file existence checks ─────────────────────────

#[test]
fn h3_vector_files_exist_and_not_empty() {
    let dir = vectors_dir();
    let files = [
        ("sas.vectors.json", 200),
        ("web-hello-open.vectors.json", 500),
        ("envelope-open.vectors.json", 500),
    ];
    for (filename, min_size) in &files {
        let path = dir.join(filename);
        let meta = std::fs::metadata(&path).unwrap_or_else(|e| panic!("{}: {}", path.display(), e));
        assert!(
            meta.len() > *min_size,
            "{} suspiciously small ({} bytes)",
            filename,
            meta.len()
        );
    }
}
