//! Deterministic golden vector generator.
//!
//! Reproduces the exact JSON vectors originally generated by the TypeScript
//! SDK (`scripts/print-test-vectors.mjs`). Uses the same fixed keypairs,
//! nonces, and plaintexts to produce byte-for-byte identical output.
//!
//! TEST FIXTURES ONLY — keypairs are publicly known and MUST NOT be used
//! in production.

use base64::engine::general_purpose::STANDARD;
use base64::Engine;
use crypto_box::{
    aead::{Aead, Payload},
    Nonce, SalsaBox, SecretKey,
};
use serde::Serialize;

// ── Helpers ─────────────────────────────────────────────────────────

fn to_hex(bytes: &[u8]) -> String {
    bytes.iter().map(|b| format!("{:02x}", b)).collect()
}

fn make_secret(offset: u8) -> [u8; 32] {
    let mut s = [0u8; 32];
    for (i, b) in s.iter_mut().enumerate() {
        *b = (i as u8).wrapping_add(offset);
    }
    s
}

fn make_nonce(offset: u8) -> [u8; 24] {
    let mut n = [0u8; 24];
    for (i, b) in n.iter_mut().enumerate() {
        *b = (i as u8).wrapping_add(offset);
    }
    n
}

fn seal_with_fixed_nonce(
    plaintext: &[u8],
    nonce_bytes: &[u8; 24],
    receiver_pk: &crypto_box::PublicKey,
    sender_sk: &SecretKey,
) -> String {
    let salsa_box = SalsaBox::new(receiver_pk, sender_sk);
    let nonce = Nonce::from_slice(nonce_bytes);
    let ciphertext = salsa_box
        .encrypt(
            nonce,
            Payload {
                msg: plaintext,
                aad: &[],
            },
        )
        .expect("encryption must not fail with valid inputs");
    let mut combined = Vec::with_capacity(24 + ciphertext.len());
    combined.extend_from_slice(nonce_bytes);
    combined.extend_from_slice(&ciphertext);
    STANDARD.encode(&combined)
}

// ── Fixed inputs ────────────────────────────────────────────────────

fn keypair_from_offset(offset: u8) -> ([u8; 32], SecretKey, crypto_box::PublicKey) {
    let secret = make_secret(offset);
    let sk = SecretKey::from(secret);
    let pk = sk.public_key();
    (secret, sk, pk)
}

fn plain_256() -> [u8; 256] {
    let mut p = [0u8; 256];
    for (i, b) in p.iter_mut().enumerate() {
        *b = i as u8;
    }
    p
}

// ── box-payload schema ──────────────────────────────────────────────

#[derive(Serialize)]
struct BoxPayloadVectors {
    #[serde(rename = "_WARNING")]
    warning: String,
    description: String,
    sender: KeypairData,
    receiver: KeypairData,
    eve: KeypairData,
    vectors: Vec<BoxVector>,
    corrupt_vectors: Vec<CorruptVector>,
}

#[derive(Serialize)]
struct KeypairData {
    #[serde(rename = "publicKey_base64")]
    public_key_base64: String,
    #[serde(rename = "secretKey_base64")]
    secret_key_base64: String,
    #[serde(rename = "publicKey_hex")]
    public_key_hex: String,
    #[serde(rename = "secretKey_hex")]
    secret_key_hex: String,
}

#[derive(Serialize)]
struct BoxVector {
    id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    plaintext_utf8: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    plaintext_hex: Option<String>,
    nonce_hex: String,
    sealed_base64: String,
}

#[derive(Serialize)]
struct CorruptVector {
    id: String,
    description: String,
    sealed_base64: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    use_eve_as_sender: Option<bool>,
    expected_error: String,
}

impl KeypairData {
    fn from_parts(pk: &crypto_box::PublicKey, sk_bytes: &[u8; 32]) -> Self {
        Self {
            public_key_base64: STANDARD.encode(pk.as_bytes()),
            secret_key_base64: STANDARD.encode(sk_bytes),
            public_key_hex: to_hex(pk.as_bytes()),
            secret_key_hex: to_hex(sk_bytes),
        }
    }
}

// ── framing schema ──────────────────────────────────────────────────

#[derive(Serialize)]
struct FramingVectors {
    #[serde(rename = "_WARNING")]
    warning: String,
    description: String,
    constants: FramingConstants,
    vectors: Vec<FramingVector>,
}

#[derive(Serialize)]
struct FramingConstants {
    nonce_length: usize,
    box_overhead: usize,
}

#[derive(Serialize)]
struct FramingVector {
    id: String,
    sealed_base64: String,
    expected_decoded_length: usize,
    expected_nonce_hex: String,
    expected_ciphertext_length: usize,
    plaintext_length: usize,
}

// ── Generators ──────────────────────────────────────────────────────

/// Generate the box-payload vectors JSON string.
pub fn generate_box_payload_json() -> String {
    let (sender_sk_bytes, sender_sk, sender_pk) = keypair_from_offset(1);
    let (receiver_sk_bytes, _, receiver_pk) = keypair_from_offset(33);
    let (eve_sk_bytes, _, eve_pk) = keypair_from_offset(65);

    let nonce_a = make_nonce(0);
    let nonce_b = make_nonce(24);

    let plain_hello = b"Hello, Bolt!";
    let plain_empty: &[u8] = &[];
    let plain_one_byte: &[u8] = &[0xff];
    let plain_256 = plain_256();

    let sealed_hello = seal_with_fixed_nonce(plain_hello, &nonce_a, &receiver_pk, &sender_sk);
    let sealed_empty = seal_with_fixed_nonce(plain_empty, &nonce_a, &receiver_pk, &sender_sk);
    let sealed_one_byte = seal_with_fixed_nonce(plain_one_byte, &nonce_a, &receiver_pk, &sender_sk);
    let sealed_256 = seal_with_fixed_nonce(&plain_256, &nonce_b, &receiver_pk, &sender_sk);

    // Corrupt: modified — flip last bit of last byte
    let corrupt_modified = {
        let decoded = STANDARD.decode(&sealed_hello).unwrap();
        let mut copy = decoded.clone();
        let last = copy.len() - 1;
        copy[last] ^= 0x01;
        STANDARD.encode(&copy)
    };

    // Corrupt: truncated — remove last 4 bytes
    let corrupt_truncated = {
        let decoded = STANDARD.decode(&sealed_hello).unwrap();
        STANDARD.encode(&decoded[..decoded.len() - 4])
    };

    // Corrupt: nonce-only
    let corrupt_nonce_only = STANDARD.encode(nonce_a);

    let data = BoxPayloadVectors {
        warning: "TEST FIXTURES ONLY \u{2014} NEVER USE IN PRODUCTION. All keypairs are deterministic, publicly known, and not valid cryptographic material for real deployments.".to_string(),
        description: "Deterministic NaCl box payload test vectors for @the9ines/bolt-core. Generated by scripts/print-test-vectors.mjs.".to_string(),
        sender: KeypairData::from_parts(&sender_pk, &sender_sk_bytes),
        receiver: KeypairData::from_parts(&receiver_pk, &receiver_sk_bytes),
        eve: KeypairData::from_parts(&eve_pk, &eve_sk_bytes),
        vectors: vec![
            BoxVector {
                id: "hello-bolt".to_string(),
                plaintext_utf8: Some("Hello, Bolt!".to_string()),
                plaintext_hex: Some(to_hex(plain_hello)),
                nonce_hex: to_hex(&nonce_a),
                sealed_base64: sealed_hello.clone(),
            },
            BoxVector {
                id: "empty-payload".to_string(),
                plaintext_utf8: Some(String::new()),
                plaintext_hex: Some(String::new()),
                nonce_hex: to_hex(&nonce_a),
                sealed_base64: sealed_empty.clone(),
            },
            BoxVector {
                id: "single-byte-ff".to_string(),
                plaintext_utf8: None,
                plaintext_hex: Some(to_hex(plain_one_byte)),
                nonce_hex: to_hex(&nonce_a),
                sealed_base64: sealed_one_byte.clone(),
            },
            BoxVector {
                id: "256-byte-pattern".to_string(),
                plaintext_utf8: None,
                plaintext_hex: Some(to_hex(&plain_256)),
                nonce_hex: to_hex(&nonce_b),
                sealed_base64: sealed_256.clone(),
            },
        ],
        corrupt_vectors: vec![
            CorruptVector {
                id: "modified-ciphertext".to_string(),
                description: "Last byte of sealed payload flipped".to_string(),
                sealed_base64: corrupt_modified,
                use_eve_as_sender: None,
                expected_error: "Decryption failed".to_string(),
            },
            CorruptVector {
                id: "truncated-ciphertext".to_string(),
                description: "Last 4 bytes removed from sealed payload".to_string(),
                sealed_base64: corrupt_truncated,
                use_eve_as_sender: None,
                expected_error: "Decryption failed".to_string(),
            },
            CorruptVector {
                id: "wrong-sender-key".to_string(),
                description: "Receiver opens with eve's public key instead of sender's"
                    .to_string(),
                sealed_base64: sealed_hello,
                use_eve_as_sender: Some(true),
                expected_error: "Decryption failed".to_string(),
            },
            CorruptVector {
                id: "nonce-only".to_string(),
                description:
                    "Payload contains only a 24-byte nonce with no ciphertext (empty ciphertext)"
                        .to_string(),
                sealed_base64: corrupt_nonce_only,
                use_eve_as_sender: None,
                expected_error: "Decryption failed".to_string(),
            },
        ],
    };

    serde_json::to_string_pretty(&data).unwrap() + "\n"
}

/// Generate the framing vectors JSON string.
pub fn generate_framing_json() -> String {
    let (_, sender_sk, _) = keypair_from_offset(1);
    let (_, _, receiver_pk) = keypair_from_offset(33);

    let nonce_a = make_nonce(0);
    let nonce_b = make_nonce(24);

    let plain_hello = b"Hello, Bolt!";
    let plain_empty: &[u8] = &[];
    let plain_one_byte: &[u8] = &[0xff];
    let plain_256 = plain_256();

    let sealed_hello = seal_with_fixed_nonce(plain_hello, &nonce_a, &receiver_pk, &sender_sk);
    let sealed_empty = seal_with_fixed_nonce(plain_empty, &nonce_a, &receiver_pk, &sender_sk);
    let sealed_one_byte = seal_with_fixed_nonce(plain_one_byte, &nonce_a, &receiver_pk, &sender_sk);
    let sealed_256 = seal_with_fixed_nonce(&plain_256, &nonce_b, &receiver_pk, &sender_sk);

    let framing_entry = |id: &str, sealed: &str, plaintext_len: usize| -> FramingVector {
        let decoded = STANDARD.decode(sealed).unwrap();
        FramingVector {
            id: id.to_string(),
            sealed_base64: sealed.to_string(),
            expected_decoded_length: decoded.len(),
            expected_nonce_hex: to_hex(&decoded[..24]),
            expected_ciphertext_length: plaintext_len + 16,
            plaintext_length: plaintext_len,
        }
    };

    let data = FramingVectors {
        warning: "TEST FIXTURES ONLY \u{2014} NEVER USE IN PRODUCTION. Sealed payloads use deterministic, publicly known test keypairs.".to_string(),
        description: "Wire format framing test vectors for @the9ines/bolt-core. Verifies nonce||ciphertext layout.".to_string(),
        constants: FramingConstants {
            nonce_length: 24,
            box_overhead: 16,
        },
        vectors: vec![
            framing_entry("hello-bolt-framing", &sealed_hello, plain_hello.len()),
            framing_entry("empty-framing", &sealed_empty, 0),
            framing_entry("single-byte-framing", &sealed_one_byte, 1),
            framing_entry("256-byte-framing", &sealed_256, 256),
        ],
    };

    serde_json::to_string_pretty(&data).unwrap() + "\n"
}
