/**
 * H3 Cross-Implementation Golden Vector Generator
 *
 * Generates:
 *   sas.vectors.json              — SAS computation test vectors
 *   web-hello-open.vectors.json   — HELLO open/decode test vectors
 *   envelope-open.vectors.json    — ProfileEnvelopeV1 open/decode test vectors
 *
 * Uses the SAME fixed keypairs and nonce scheme as print-test-vectors.mjs.
 * Sealed payloads are produced with fixed nonces so output is deterministic.
 *
 * Usage:
 *   node scripts/generate-h3-vectors.mjs          # write files
 *   node scripts/generate-h3-vectors.mjs --check  # compare only (CI use)
 */

import tweetnacl from 'tweetnacl';
import tweetnacl_util from 'tweetnacl-util';
import { createHash } from 'node:crypto';
import { writeFileSync, readFileSync, existsSync, mkdirSync } from 'node:fs';
import { join, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';

const { box } = tweetnacl;
const { encodeBase64 } = tweetnacl_util;

const __dirname = dirname(fileURLToPath(import.meta.url));
const root = join(__dirname, '..');
const vectorDir = join(root, '__tests__', 'vectors');

// ── Helpers ──────────────────────────────────────────────

function toHex(arr) {
  return Array.from(arr).map(b => b.toString(16).padStart(2, '0')).join('');
}

function fromHex(hex) {
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2) {
    bytes[i / 2] = parseInt(hex.substring(i, i + 2), 16);
  }
  return bytes;
}

function sealWithFixedNonce(plaintext, nonce, receiverPub, senderSec) {
  const encrypted = box(plaintext, nonce, receiverPub, senderSec);
  const combined = new Uint8Array(nonce.length + encrypted.length);
  combined.set(nonce);
  combined.set(encrypted, nonce.length);
  return encodeBase64(combined);
}

// ── SAS algorithm (mirrors sas.ts exactly) ───────────────

function sort32(a, b) {
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      const first = a[i] < b[i] ? a : b;
      const second = a[i] < b[i] ? b : a;
      const result = new Uint8Array(first.length + second.length);
      result.set(first);
      result.set(second, first.length);
      return result;
    }
  }
  const result = new Uint8Array(a.length + b.length);
  result.set(a);
  result.set(b, a.length);
  return result;
}

function computeSasSync(identityA, identityB, ephemeralA, ephemeralB) {
  const sortedIdentity = sort32(identityA, identityB);
  const sortedEphemeral = sort32(ephemeralA, ephemeralB);
  const combined = new Uint8Array(sortedIdentity.length + sortedEphemeral.length);
  combined.set(sortedIdentity);
  combined.set(sortedEphemeral, sortedIdentity.length);
  const hash = createHash('sha256').update(combined).digest();
  return toHex(hash).substring(0, 6).toUpperCase();
}

// ── Fixed keypairs (same as print-test-vectors.mjs) ──────

const senderSecret = new Uint8Array(32);
for (let i = 0; i < 32; i++) senderSecret[i] = i + 1;
const senderKp = box.keyPair.fromSecretKey(senderSecret);

const receiverSecret = new Uint8Array(32);
for (let i = 0; i < 32; i++) receiverSecret[i] = i + 33;
const receiverKp = box.keyPair.fromSecretKey(receiverSecret);

const eveSecret = new Uint8Array(32);
for (let i = 0; i < 32; i++) eveSecret[i] = i + 65;
const eveKp = box.keyPair.fromSecretKey(eveSecret);

// Additional SAS test keys (from existing sas.test.ts)
const keyA = new Uint8Array(32); keyA[0] = 0x01; keyA[31] = 0xAA;
const keyB = new Uint8Array(32); keyB[0] = 0x02; keyB[31] = 0xBB;
const ephA = new Uint8Array(32); ephA[0] = 0x10; ephA[31] = 0xCC;
const ephB = new Uint8Array(32); ephB[0] = 0x20; ephB[31] = 0xDD;

// Fixed nonces for HELLO/envelope vectors
// Nonce C: bytes [48..71] — distinct from existing nonceA/nonceB
const nonceC = new Uint8Array(24);
for (let i = 0; i < 24; i++) nonceC[i] = 48 + i;

// Nonce D: bytes [72..95]
const nonceD = new Uint8Array(24);
for (let i = 0; i < 24; i++) nonceD[i] = 72 + i;

// Nonce E: bytes [96..119]
const nonceE = new Uint8Array(24);
for (let i = 0; i < 24; i++) nonceE[i] = 96 + i;

// ── 1. SAS Vectors ──────────────────────────────────────

const sasVectors = {
  version: 1,
  _WARNING: 'TEST FIXTURES ONLY — NEVER USE IN PRODUCTION. All keys are deterministic test fixtures.',
  description: 'SAS (Short Authentication String) golden vectors. Generated by scripts/generate-h3-vectors.mjs.',
  cases: [
    {
      name: 'sas_sparse_keys',
      description: 'Sparse test keys (mostly zeros with sentinel bytes at positions 0 and 31)',
      identity_a_hex: toHex(keyA),
      identity_b_hex: toHex(keyB),
      ephemeral_a_hex: toHex(ephA),
      ephemeral_b_hex: toHex(ephB),
      expected_sas: computeSasSync(keyA, keyB, ephA, ephB),
    },
    {
      name: 'sas_box_payload_keys_symmetric',
      description: 'Uses sender + receiver public keys from box-payload.vectors.json for both identity and ephemeral',
      identity_a_hex: toHex(senderKp.publicKey),
      identity_b_hex: toHex(receiverKp.publicKey),
      ephemeral_a_hex: toHex(senderKp.publicKey),
      ephemeral_b_hex: toHex(receiverKp.publicKey),
      expected_sas: computeSasSync(senderKp.publicKey, receiverKp.publicKey, senderKp.publicKey, receiverKp.publicKey),
    },
    {
      name: 'sas_mixed_keys',
      description: 'Identity: receiver + eve; ephemeral: sender + receiver from box-payload.vectors.json',
      identity_a_hex: toHex(receiverKp.publicKey),
      identity_b_hex: toHex(eveKp.publicKey),
      ephemeral_a_hex: toHex(senderKp.publicKey),
      ephemeral_b_hex: toHex(receiverKp.publicKey),
      expected_sas: computeSasSync(receiverKp.publicKey, eveKp.publicKey, senderKp.publicKey, receiverKp.publicKey),
    },
    {
      name: 'sas_all_different_keys',
      description: 'All four keys are distinct: sender_pk, receiver_pk, eve_pk, and sparse keyA',
      identity_a_hex: toHex(senderKp.publicKey),
      identity_b_hex: toHex(eveKp.publicKey),
      ephemeral_a_hex: toHex(receiverKp.publicKey),
      ephemeral_b_hex: toHex(keyA),
      expected_sas: computeSasSync(senderKp.publicKey, eveKp.publicKey, receiverKp.publicKey, keyA),
    },
  ],
};

// ── 2. HELLO Open Vectors ───────────────────────────────

// HELLO inner payloads (matching WebRTCService.ts initiateHello format)
const helloInner1 = {
  type: 'hello',
  version: 1,
  identityPublicKey: encodeBase64(senderKp.publicKey),
  capabilities: ['bolt.file-hash', 'bolt.profile-envelope-v1'],
};

const helloInner2 = {
  type: 'hello',
  version: 1,
  identityPublicKey: encodeBase64(receiverKp.publicKey),
  capabilities: ['bolt.profile-envelope-v1'],
};

const helloInner3 = {
  type: 'hello',
  version: 1,
  identityPublicKey: encodeBase64(eveKp.publicKey),
  capabilities: [],
};

const helloInner1Bytes = new TextEncoder().encode(JSON.stringify(helloInner1));
const helloInner2Bytes = new TextEncoder().encode(JSON.stringify(helloInner2));
const helloInner3Bytes = new TextEncoder().encode(JSON.stringify(helloInner3));

// Sender seals for receiver (sender_secret + receiver_public)
const sealedHello1 = sealWithFixedNonce(helloInner1Bytes, nonceC, receiverKp.publicKey, senderKp.secretKey);
// Receiver seals for sender (receiver_secret + sender_public)
const sealedHello2 = sealWithFixedNonce(helloInner2Bytes, nonceD, senderKp.publicKey, receiverKp.secretKey);
// Eve seals for receiver (eve_secret + receiver_public)
const sealedHello3 = sealWithFixedNonce(helloInner3Bytes, nonceE, receiverKp.publicKey, eveKp.secretKey);

const webHelloOpenVectors = {
  version: 1,
  _WARNING: 'TEST FIXTURES ONLY — NEVER USE IN PRODUCTION. All keypairs are deterministic test fixtures.',
  description: 'Web HELLO open/decode golden vectors. Tests openBoxPayload + JSON parse of inner HELLO. Generated by scripts/generate-h3-vectors.mjs.',
  cases: [
    {
      name: 'hello_open_sender_to_receiver',
      description: 'Sender encrypts HELLO for receiver with full capabilities',
      sender_public_hex: toHex(senderKp.publicKey),
      receiver_secret_hex: toHex(receiverKp.secretKey),
      sealed_payload_base64: sealedHello1,
      expected_inner: helloInner1,
    },
    {
      name: 'hello_open_receiver_to_sender',
      description: 'Receiver encrypts HELLO for sender with envelope capability only',
      sender_public_hex: toHex(receiverKp.publicKey),
      receiver_secret_hex: toHex(senderKp.secretKey),
      sealed_payload_base64: sealedHello2,
      expected_inner: helloInner2,
    },
    {
      name: 'hello_open_eve_to_receiver',
      description: 'Eve encrypts HELLO for receiver with empty capabilities (legacy peer)',
      sender_public_hex: toHex(eveKp.publicKey),
      receiver_secret_hex: toHex(receiverKp.secretKey),
      sealed_payload_base64: sealedHello3,
      expected_inner: helloInner3,
    },
  ],
};

// ── 3. Envelope Open Vectors ────────────────────────────

// Nonce F: bytes [120..143]
const nonceF = new Uint8Array(24);
for (let i = 0; i < 24; i++) nonceF[i] = 120 + i;

// Nonce G: bytes [144..167]
const nonceG = new Uint8Array(24);
for (let i = 0; i < 24; i++) nonceG[i] = 144 + i;

// Inner messages for envelope vectors
const pingInner = { type: 'ping', ts_ms: 1700000000000 };
const pongInner = { type: 'pong', ts_ms: 1700000001000, reply_to_ms: 1700000000000 };
const appMsgInner = { type: 'app_message', text: 'Hello from vector test' };

const pingBytes = new TextEncoder().encode(JSON.stringify(pingInner));
const pongBytes = new TextEncoder().encode(JSON.stringify(pongInner));
const appMsgBytes = new TextEncoder().encode(JSON.stringify(appMsgInner));

// Seal inner messages (sender_secret + receiver_public)
const sealedPing = sealWithFixedNonce(pingBytes, nonceC, receiverKp.publicKey, senderKp.secretKey);
const sealedPong = sealWithFixedNonce(pongBytes, nonceD, senderKp.publicKey, receiverKp.secretKey);
const sealedAppMsg = sealWithFixedNonce(appMsgBytes, nonceF, receiverKp.publicKey, senderKp.secretKey);

const envelopeOpenVectors = {
  version: 1,
  _WARNING: 'TEST FIXTURES ONLY — NEVER USE IN PRODUCTION. All keypairs are deterministic test fixtures.',
  description: 'ProfileEnvelopeV1 open/decode golden vectors. Tests envelope parsing + openBoxPayload + JSON parse of inner message. Generated by scripts/generate-h3-vectors.mjs.',
  cases: [
    {
      name: 'envelope_open_ping',
      description: 'Sender sends ping wrapped in ProfileEnvelopeV1 to receiver',
      sender_public_hex: toHex(senderKp.publicKey),
      receiver_secret_hex: toHex(receiverKp.secretKey),
      envelope_json: {
        type: 'profile-envelope',
        version: 1,
        encoding: 'base64',
        payload: sealedPing,
      },
      expected_inner: pingInner,
    },
    {
      name: 'envelope_open_pong',
      description: 'Receiver sends pong wrapped in ProfileEnvelopeV1 to sender',
      sender_public_hex: toHex(receiverKp.publicKey),
      receiver_secret_hex: toHex(senderKp.secretKey),
      envelope_json: {
        type: 'profile-envelope',
        version: 1,
        encoding: 'base64',
        payload: sealedPong,
      },
      expected_inner: pongInner,
    },
    {
      name: 'envelope_open_app_message',
      description: 'Sender sends app_message wrapped in ProfileEnvelopeV1 to receiver',
      sender_public_hex: toHex(senderKp.publicKey),
      receiver_secret_hex: toHex(receiverKp.secretKey),
      envelope_json: {
        type: 'profile-envelope',
        version: 1,
        encoding: 'base64',
        payload: sealedAppMsg,
      },
      expected_inner: appMsgInner,
    },
  ],
};

// ── Output ──────────────────────────────────────────────

const checkMode = process.argv.includes('--check');
const files = [
  ['sas.vectors.json', sasVectors],
  ['web-hello-open.vectors.json', webHelloOpenVectors],
  ['envelope-open.vectors.json', envelopeOpenVectors],
];

if (checkMode) {
  let mismatch = false;
  for (const [filename, data] of files) {
    const committedPath = join(vectorDir, filename);
    const generated = JSON.stringify(data, null, 2) + '\n';
    if (!existsSync(committedPath)) {
      console.error(`MISSING: ${committedPath}`);
      mismatch = true;
      continue;
    }
    const committed = readFileSync(committedPath, 'utf-8');
    if (committed !== generated) {
      console.error(`DRIFT: ${filename} — committed file does not match generated output.`);
      console.error('Run: node scripts/generate-h3-vectors.mjs');
      mismatch = true;
    } else {
      console.log(`OK: ${filename}`);
    }
  }
  process.exit(mismatch ? 1 : 0);
} else {
  mkdirSync(vectorDir, { recursive: true });
  for (const [filename, data] of files) {
    const path = join(vectorDir, filename);
    writeFileSync(path, JSON.stringify(data, null, 2) + '\n');
    console.log(`Written: ${path}`);
  }
}
