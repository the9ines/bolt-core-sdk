/**
 * Generate deterministic NaCl box test vectors for cross-implementation interop.
 *
 * Usage:
 *   node scripts/print-test-vectors.mjs          # write files + print JSON
 *   node scripts/print-test-vectors.mjs --print   # print only (no file write)
 *
 * Vectors use fixed keypairs and fixed nonces so output is fully deterministic.
 * Downstream Rust/libdatachannel implementations can verify against these vectors.
 */

import tweetnacl from 'tweetnacl';
import tweetnacl_util from 'tweetnacl-util';
import { writeFileSync, mkdirSync } from 'node:fs';
import { join, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';

const { box } = tweetnacl;
const { encodeBase64 } = tweetnacl_util;

const __dirname = dirname(fileURLToPath(import.meta.url));
const root = join(__dirname, '..');
const vectorDir = join(root, '__tests__', 'vectors');

// ── Helpers ──────────────────────────────────────────────

function toHex(arr) {
  return Array.from(arr).map(b => b.toString(16).padStart(2, '0')).join('');
}

function sealWithFixedNonce(plaintext, nonce, receiverPub, senderSec) {
  const encrypted = box(plaintext, nonce, receiverPub, senderSec);
  const combined = new Uint8Array(nonce.length + encrypted.length);
  combined.set(nonce);
  combined.set(encrypted, nonce.length);
  return encodeBase64(combined);
}

// ── Fixed keypairs (deterministic from known secret keys) ──

// Sender: secretKey bytes [1..32]
const senderSecret = new Uint8Array(32);
for (let i = 0; i < 32; i++) senderSecret[i] = i + 1;
const senderKp = box.keyPair.fromSecretKey(senderSecret);

// Receiver: secretKey bytes [33..64]
const receiverSecret = new Uint8Array(32);
for (let i = 0; i < 32; i++) receiverSecret[i] = i + 33;
const receiverKp = box.keyPair.fromSecretKey(receiverSecret);

// Eve (wrong key): secretKey bytes [65..96]
const eveSecret = new Uint8Array(32);
for (let i = 0; i < 32; i++) eveSecret[i] = i + 65;
const eveKp = box.keyPair.fromSecretKey(eveSecret);

// ── Fixed nonces ─────────────────────────────────────────

// Nonce A: bytes [0..23]
const nonceA = new Uint8Array(24);
for (let i = 0; i < 24; i++) nonceA[i] = i;

// Nonce B: bytes [24..47]
const nonceB = new Uint8Array(24);
for (let i = 0; i < 24; i++) nonceB[i] = 24 + i;

// ── Plaintexts ───────────────────────────────────────────

const plainHello = new TextEncoder().encode('Hello, Bolt!');
const plainEmpty = new Uint8Array(0);
const plainOneByte = new Uint8Array([0xff]);
const plain256 = new Uint8Array(256);
for (let i = 0; i < 256; i++) plain256[i] = i % 256;

// ── Seal vectors ─────────────────────────────────────────

const sealedHello = sealWithFixedNonce(plainHello, nonceA, receiverKp.publicKey, senderKp.secretKey);
const sealedEmpty = sealWithFixedNonce(plainEmpty, nonceA, receiverKp.publicKey, senderKp.secretKey);
const sealedOneByte = sealWithFixedNonce(plainOneByte, nonceA, receiverKp.publicKey, senderKp.secretKey);
const sealed256 = sealWithFixedNonce(plain256, nonceB, receiverKp.publicKey, senderKp.secretKey);

// ── Corrupt variants ─────────────────────────────────────

// Modified: flip last bit of last byte
const corruptModified = (() => {
  const decoded = tweetnacl_util.decodeBase64(sealedHello);
  const copy = new Uint8Array(decoded);
  copy[copy.length - 1] ^= 0x01;
  return encodeBase64(copy);
})();

// Truncated: remove last 4 bytes
const corruptTruncated = (() => {
  const decoded = tweetnacl_util.decodeBase64(sealedHello);
  return encodeBase64(decoded.slice(0, decoded.length - 4));
})();

// Nonce-only: just the nonce, no ciphertext
const corruptNonceOnly = encodeBase64(nonceA);

// ── box-payload.vectors.json ─────────────────────────────

const boxPayload = {
  description: 'Deterministic NaCl box payload test vectors for @the9ines/bolt-core. Generated by scripts/print-test-vectors.mjs.',
  sender: {
    publicKey_base64: encodeBase64(senderKp.publicKey),
    secretKey_base64: encodeBase64(senderKp.secretKey),
    publicKey_hex: toHex(senderKp.publicKey),
    secretKey_hex: toHex(senderKp.secretKey),
  },
  receiver: {
    publicKey_base64: encodeBase64(receiverKp.publicKey),
    secretKey_base64: encodeBase64(receiverKp.secretKey),
    publicKey_hex: toHex(receiverKp.publicKey),
    secretKey_hex: toHex(receiverKp.secretKey),
  },
  eve: {
    publicKey_base64: encodeBase64(eveKp.publicKey),
    secretKey_base64: encodeBase64(eveKp.secretKey),
    publicKey_hex: toHex(eveKp.publicKey),
    secretKey_hex: toHex(eveKp.secretKey),
  },
  vectors: [
    {
      id: 'hello-bolt',
      plaintext_utf8: 'Hello, Bolt!',
      plaintext_hex: toHex(plainHello),
      nonce_hex: toHex(nonceA),
      sealed_base64: sealedHello,
    },
    {
      id: 'empty-payload',
      plaintext_utf8: '',
      plaintext_hex: '',
      nonce_hex: toHex(nonceA),
      sealed_base64: sealedEmpty,
    },
    {
      id: 'single-byte-ff',
      plaintext_hex: 'ff',
      nonce_hex: toHex(nonceA),
      sealed_base64: sealedOneByte,
    },
    {
      id: '256-byte-pattern',
      plaintext_hex: toHex(plain256),
      nonce_hex: toHex(nonceB),
      sealed_base64: sealed256,
    },
  ],
  corrupt_vectors: [
    {
      id: 'modified-ciphertext',
      description: 'Last byte of sealed payload flipped',
      sealed_base64: corruptModified,
      expected_error: 'Decryption failed',
    },
    {
      id: 'truncated-ciphertext',
      description: 'Last 4 bytes removed from sealed payload',
      sealed_base64: corruptTruncated,
      expected_error: 'Decryption failed',
    },
    {
      id: 'wrong-sender-key',
      description: "Receiver opens with eve's public key instead of sender's",
      sealed_base64: sealedHello,
      use_eve_as_sender: true,
      expected_error: 'Decryption failed',
    },
    {
      id: 'nonce-only',
      description: 'Payload contains only a 24-byte nonce with no ciphertext (empty ciphertext)',
      sealed_base64: corruptNonceOnly,
      expected_error: 'Decryption failed',
    },
  ],
};

// ── framing.vectors.json ─────────────────────────────────

const BOX_OVERHEAD = 16; // Poly1305 MAC

function framingEntry(id, sealedBase64, plaintextLength) {
  const decoded = tweetnacl_util.decodeBase64(sealedBase64);
  return {
    id,
    sealed_base64: sealedBase64,
    expected_decoded_length: decoded.length,
    expected_nonce_hex: toHex(decoded.slice(0, 24)),
    expected_ciphertext_length: plaintextLength + BOX_OVERHEAD,
    plaintext_length: plaintextLength,
  };
}

const framing = {
  description: 'Wire format framing test vectors for @the9ines/bolt-core. Verifies nonce||ciphertext layout.',
  constants: {
    nonce_length: 24,
    box_overhead: BOX_OVERHEAD,
  },
  vectors: [
    framingEntry('hello-bolt-framing', sealedHello, plainHello.length),
    framingEntry('empty-framing', sealedEmpty, 0),
    framingEntry('single-byte-framing', sealedOneByte, 1),
    framingEntry('256-byte-framing', sealed256, 256),
  ],
};

// ── Output ───────────────────────────────────────────────

const printOnly = process.argv.includes('--print');

if (!printOnly) {
  mkdirSync(vectorDir, { recursive: true });
  writeFileSync(
    join(vectorDir, 'box-payload.vectors.json'),
    JSON.stringify(boxPayload, null, 2) + '\n',
  );
  writeFileSync(
    join(vectorDir, 'framing.vectors.json'),
    JSON.stringify(framing, null, 2) + '\n',
  );
  console.log('Vectors written to __tests__/vectors/');
}

console.log('\n=== box-payload.vectors.json ===');
console.log(JSON.stringify(boxPayload, null, 2));
console.log('\n=== framing.vectors.json ===');
console.log(JSON.stringify(framing, null, 2));
