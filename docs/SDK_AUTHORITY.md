# Bolt Core SDK — Authority Model

Defines which implementation is canonical, how adapter implementations
relate to it, and what gates enforce cross-implementation compatibility.

Keywords: RFC 2119 (MUST, MUST NOT, REQUIRED, SHALL, SHOULD, MAY).

## Core Rule

**Canonical truth = contracts (`PROTOCOL.md`, `TRANSPORT_CONTRACT.md`) +
golden vectors + Rust crate (`rust/bolt-core/`).**

TypeScript (`@the9ines/bolt-core`) is supported but MUST pass
compatibility tests against canonical vectors. It does not define
protocol behavior.

## 1. Canonical Implementation

The **Rust crate** (`rust/bolt-core/`, package name `bolt-core`) is the
canonical reference implementation of Bolt Core for ByteBolt-class products
and all future native/server deployments.

"Canonical" means:

- When behavior is ambiguous, the Rust implementation's output is
  authoritative.
- New protocol primitives are implemented in Rust first.
- Golden test vectors are generated from the canonical implementation
  (after Rust crypto is functional; until then, existing TS-generated
  vectors remain authoritative).

## 2. Adapter Implementations

The **TypeScript package** (`@the9ines/bolt-core`, `ts/bolt-core/`) is a
supported adapter implementation. It remains a first-class SDK for
browser-based products (localbolt, localbolt-v3, localbolt-app web layer).

Adapter rules:

- An adapter MUST produce identical outputs for identical inputs as the
  canonical implementation, verified by shared golden test vectors.
- An adapter MAY have language-idiomatic API differences (e.g., `Promise`
  vs `Result`, class vs struct) as long as wire-format behavior is
  identical.
- An adapter MUST NOT define new protocol semantics. Protocol semantics
  are defined by the canonical implementation, `PROTOCOL.md`, and
  `TRANSPORT_CONTRACT.md`.

## 3. Source of Truth Hierarchy

| Authority level | Source |
|----------------|--------|
| Protocol semantics | `PROTOCOL.md` + `TRANSPORT_CONTRACT.md` |
| Behavioral truth | Canonical implementation (Rust) + golden vectors |
| API stability (Rust) | `docs/SDK_STABILITY.md` §6 (Rust crate) |
| API stability (TS) | `docs/SDK_STABILITY.md` §1–§5 (TypeScript) |
| Transport requirements | `docs/TRANSPORT_CONTRACT.md` |
| Operator surface | `docs/DAEMON_CONTRACT.md` (bolt-daemon repo) |

## 4. Golden Vectors

Golden test vectors (`ts/bolt-core/__tests__/vectors/`) are the
machine-verifiable interop gate between implementations.

Rules:

- Vectors MUST NOT be modified without a protocol version bump or
  explicit decision documented in `PROTOCOL.md`.
- Both implementations MUST pass all vector suites as a CI gate.
- Vectors are currently generated by the TypeScript SDK. Once the Rust
  crate implements crypto primitives, vector generation SHOULD migrate
  to Rust and the TypeScript SDK MUST validate against Rust-generated
  vectors.

Current vector suites:

| Suite | File | Vectors |
|-------|------|---------|
| Box payload | `box-payload.vectors.json` | 4 valid + 4 corrupt |
| Framing | `framing.vectors.json` | 4 framing |

## 5. Versioning

The Rust crate and TypeScript package are versioned **independently**
under SemVer. They do not share version numbers.

| Package | Current version | Versioning doc |
|---------|----------------|----------------|
| `bolt-core` (Rust) | 0.1.0 | `SDK_STABILITY.md` §6 |
| `@the9ines/bolt-core` (TS) | 0.1.0 | `SDK_STABILITY.md` §1–§5 |

A breaking change in one implementation does NOT automatically require
a version bump in the other, unless the change alters shared wire format
or protocol semantics (which would require a MAJOR bump in both).

## 6. Interop Gate

Before any release of either implementation, the following MUST pass:

1. All golden vector suites parse and validate in both implementations.
2. Constants match across implementations (verified by CI).
3. No vector file has been modified without corresponding protocol
   documentation.

This gate is initially structural (JSON parsing + field validation).
It will become cryptographic once the Rust crate implements NaCl box
operations.
